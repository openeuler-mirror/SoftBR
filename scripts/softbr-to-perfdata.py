#!/usr/bin/env python3

import re
import struct
from multiprocessing import Pool, cpu_count, freeze_support
import argparse

parser = argparse.ArgumentParser(description="Convert the perf script file generated by SoftBR to binary form")

parser.add_argument("input", help="input perf script file")
parser.add_argument("-o", "--output", help="output file name, default: perf.data", default="perf.data")

args = parser.parse_args()

def parse_perf_script(input_file):
    brstack_pattern = re.compile(r"\s*((?:0x[0-9a-f]+/0x[0-9a-f]+/[pm-]/[x-]/[a-]/[0-9]+\s*)+)$")
    mmap_pattern = re.compile(r"(PERF_RECORD_MMAP) (-?\d+)/(\d+): \[(0x[0-9a-f]+)\((0x[0-9a-f]+)\) @ ((?:0x)*[0-9a-f]+)\]: ([rx]) (.*)")
    mmap2_pattern = re.compile(r"(PERF_RECORD_MMAP2) (-?\d+)/(\d+): \[(0x[0-9a-f]+)\((0x[0-9a-f]+)\) @ ((?:0x)*[0-9a-f]+) ([0-9a-f]{2}):([0-9a-f]{2}) (\d+) (\d+)\]: ([r-])([w-])([x-])([sp]) (.*)")
    pid_pattern = re.compile("^\d+$")
    callchain_pattern = re.compile("^\s*[0-9a-f]+$")

    def line_parser():
        with open(input_file, 'r') as f:
            for line in f:
                if pid_pattern.match(line):
                    pid = int(line)
                    callchain = []
                    while (callchain_pattern.match(line := next(f, ''))):
                        callchain.append(int(line.strip(), 16))
                    if brstack_match := brstack_pattern.match(line):
                        processed_brstack = pid, callchain, [
                            (
                                int(fromip, 16),
                                int(toip, 16),
                                (0b10 if pred == 'p' else 0b01) |
                                (1 << 2 if in_tx == 'x' else 0) |
                                (1 << 3 if abort == 'a' else 0) |
                                (int(cycles) << 4)
                            )
                            for (fromip, toip, pred, in_tx, abort, cycles) in (
                                item.split('/') for item in brstack_match.group(1).split()
                            )
                        ]
                        yield ('brstack', processed_brstack)
                elif mmap_match := mmap_pattern.match(line):
                    yield ('mmap', mmap_match)
                elif mmap2_match := mmap2_pattern.match(line):
                    yield ('mmap2', mmap2_match)

    brstack_items = []
    mmap_items = []
    mmap2_items = []
    chunk_size = 10000

    current_chunk = []
    for item in line_parser():
        current_chunk.append(item)
        if len(current_chunk) >= chunk_size:
            for typ, data in current_chunk:
                if typ == 'brstack':
                    brstack_items.append(data)
                elif typ == 'mmap':
                    mmap_items.append(data)
                elif typ == 'mmap2':
                    mmap2_items.append(data)
            current_chunk = []

    for typ, data in current_chunk:
        if typ == 'brstack':
            brstack_items.append(data)
        elif typ == 'mmap':
            mmap_items.append(data)
        elif typ == 'mmap2':
            mmap2_items.append(data)

    return brstack_items, mmap_items, mmap2_items

def build_attr():
    data  = struct.pack('<I', 0)        # type
    data += struct.pack('<I', 0x78)     # size
    data += struct.pack('<Q', 0)        # config
    data += struct.pack('<Q', 0)        # period/freq
    data += struct.pack('<Q', 0x803)    # sample type
    data += struct.pack('<Q', 0x4)      # read format
    data += struct.pack('<Q', 0x60902463)
    data += struct.pack('<I', 0)        # wakeup
    data += struct.pack('<I', 0)        # bp_type
    data += struct.pack('<Q', 0)
    data += struct.pack('<Q', 0)
    data += struct.pack('<Q', 0x9)      # branch sample type
    data += struct.pack('<Q', 0)        # sample_regs_user
    data += struct.pack('<I', 0)        # sample_stack_user
    data += struct.pack('<i', 0)        # clockid
    data += struct.pack('<Q', 0)        # sample_regs_intr
    data += struct.pack('<I', 0)        # aux_watermark
    data += struct.pack('<H', 0)        # sample_max_stack
    data += struct.pack('<H', 0)
    data += struct.pack('<I', 0)
    data += struct.pack('<I', 0)
    return data

def _pack_brstack_chunk(chunk):
    header_fmt = struct.Struct('<IHH')
    ip_fmt =  struct.Struct('<Q')
    pid_fmt = struct.Struct('<II')
    brstack_fmt = struct.Struct('<QQQ')
    nr_fmt = struct.Struct('<Q')
    buffer = []
    _type = 0x9
    _misc = 0x2
    for pid, callchain, brstack in chunk:
        # header + ip + pid + tid + nr + brstack
        _size = 8 + 8 + 4 + 4 + 8 + 24 * len(brstack)
        _header = header_fmt.pack(_type, _misc, _size)
        _ip = ip_fmt.pack(callchain[0])
        _pid = pid_fmt.pack(pid, pid)
        _nr_brstack = nr_fmt.pack(len(brstack))
        _brstack = (brstack_fmt.pack(fromip, toip, flags) for fromip, toip, flags in brstack)
        buffer.append(_header)
        buffer.append(_ip)
        buffer.append(_pid)
        buffer.append(_nr_brstack)
        buffer.extend(_brstack)
    return b''.join(buffer)

def build_brstack_parallel(brstack_items):
    chunk_size = max(1, len(brstack_items) // (cpu_count() * 2))
    chunks = [brstack_items[i:i+chunk_size] for i in range(0, len(brstack_items), chunk_size)]

    with Pool() as pool:
        results = pool.imap_unordered(_pack_brstack_chunk, chunks)
        return b''.join(results)
    
def build_mmap(mmap_items):
    data = bytes(0)
    for mmap_item in mmap_items:
        data += struct.pack('<I', 0x1)  # type PERF_RECORD_MMAP
        misc = 1 << 13 if mmap_item.group(7) == 'r' else 0
        data += struct.pack('<H', misc) # misc
        filename_len = int((len(mmap_item.group(8)) + 8) / 8) * 8
        data += struct.pack('<H', 8 + 4 + 4 + 8 + 8 + 8 + filename_len) # size
        data += struct.pack('<i', int(mmap_item.group(2)))      # pid
        data += struct.pack('<I', int(mmap_item.group(3)))      # tid
        data += struct.pack('<Q', int(mmap_item.group(4), 16))  # addr
        data += struct.pack('<Q', int(mmap_item.group(5), 16))  # len
        data += struct.pack('<Q', int(mmap_item.group(6), 16))  # pgoff
        data += struct.pack(f'{filename_len}s', mmap_item.group(8).encode('utf-8')) # filename
    return data

def build_mmap2(mmap2_items):
    data = bytes(0)
    for mmap2_item in mmap2_items:
        data += struct.pack('<I', 0xA)  # type PERF_RECORD_MMAP2
        data += struct.pack('<H', 0x2)  # misc
        filename_len = int((len(mmap2_item.group(15)) + 8) / 8) * 8
        data += struct.pack('<H', 8 + 4 + 4 + 8 + 8 + 8 + 4 + 4 + 8 + 8 + 4 + 4 + filename_len) # size
        data += struct.pack('<i', int(mmap2_item.group(2)))     # pid
        data += struct.pack('<I', int(mmap2_item.group(3)))     # tid
        data += struct.pack('<Q', int(mmap2_item.group(4), 16)) # addr
        data += struct.pack('<Q', int(mmap2_item.group(5), 16)) # len
        data += struct.pack('<Q', int(mmap2_item.group(6), 16)) # pgoff
        data += struct.pack('<I', int(mmap2_item.group(7), 16)) # maj
        data += struct.pack('<I', int(mmap2_item.group(8), 16)) # min
        data += struct.pack('<Q', int(mmap2_item.group(9)))     # ino
        data += struct.pack('<Q', int(mmap2_item.group(10)))    # ino_generation
        prot = 0
        if mmap2_item.group(11) == 'r' : prot |= 0x1
        if mmap2_item.group(12) == 'w' : prot |= 0x2
        if mmap2_item.group(13) == 'x' : prot |= 0x4
        data += struct.pack('<I', prot)
        flags = 0
        if mmap2_item.group(14) == 's' : flags |= 0x1
        data += struct.pack('<I', flags)
        data += struct.pack(f'{filename_len}s', mmap2_item.group(15).encode('utf-8')) # filename
    return data

def build_perf_data(input_file):
    brstack_items, mmap_items, mmap2_items = parse_perf_script(input_file)

    brstack_data = build_brstack_parallel(brstack_items)
    mmap_data = build_mmap(mmap_items)
    mmap2_data = build_mmap2(mmap2_items)
    attr_data = build_attr()

    header = struct.pack('<8s', "PERFILE2".encode('utf-8')) # magic
    header += struct.pack('<Q', 0x68)           # size
    header += struct.pack('<Q', 0x88)           # per_attr_size
    header += struct.pack('<Q', 0x68)           # attr_offset
    header += struct.pack('<Q', 0x88)           # attr_size
    header += struct.pack('<Q', 0x68 + 0x88)    # data_offset
    header += struct.pack('<Q', len(mmap_data) + len(mmap2_data) + len(brstack_data))  # data_size
    header += struct.pack('<Q', 0)              # event_types_offset
    header += struct.pack('<Q', 0)              # event_types_size
    header += struct.pack('<Q', 0)              # flags
    header += struct.pack('<Q', 0)
    header += struct.pack('<Q', 0)
    header += struct.pack('<Q', 0)
    data = bytes(0)
    data += header
    data += attr_data
    data += struct.pack('<Q', 0x68)
    data += struct.pack('<Q', 0)
    data += mmap_data
    data += mmap2_data
    data += brstack_data
    return data

def write_file(data):
    with open(f"{args.output}", 'wb', buffering=16*1024*1024) as f:
        f.write(data)

def main():
    data = build_perf_data(f"{args.input}")
    write_file(data)

if __name__ == '__main__':
    freeze_support()
    main()
